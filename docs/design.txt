Zeta Components - Workflow CouchDB Tiein Design
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:Author: Benjamin Eberlei

Design Description
==================

The WorkflowCouchDBTiein provides functionalities to load and save workflows into CouchDB
and to start, save and resume executions by persisting the state into CouchDB.

Characteristics
===============

-   Workflows and Executions will be assigned CouchDB UUIDs.
-   Workflows and executions are saved into a single document each.
-   Time inconsistencies due to changing workflows will be circumvented
    by saving all versions of the workflow into a substructure and associating
    each active execution with a workflow id and version.
-   Document JSON structures are crafted in a way that queries on
    various variables of the execution state are possible using CouchDB views.

Document Structure
==================

A workflow structure could look like:

    {
       "_id": "de7cdd4f1ca178ed7c287e6e27285cb7",
       "type": "zeta_workflow",
       "name": "my_workflow_slug",
       "current_version": 1234,
       "created": 1234567890,
       "versions": {
           "1234": {
               "nodes": {
                    "node_uuid1": {
                        "class": "ezcWorkflowNodeStart",
                        "configuration": {},
                        "outgoingNodes": ["node_uuid2"]
                    },
                    "node_uuid2": {
                        "class": "ezcWorkflowNodeEnd",
                        "configuration": {},
                        "outgoingNodes": []
                    }
                },
                "variableHandlers": {
                    "varName1": {
                        "class": "MyFooVarHandler",
                        "args": {}
                    },
                    "varName2": "MyBarVarHandler"
                }
            }
        }
    }

The UUIDs for nodes would be generated by asking CouchDB for more uuids.

An execution document structure could look like:

    {
        "type": "zeta_workflow_execution",
        "workflow_id": 1,
        "workflow_version": 1234,
        "execution_parent": 0,
        "execution_started": 1234567890,
        "execution_suspended": false,
        "variables": {
            "entity_id": 1234,
            "foo": "bar",
            "bar": "baz",
            "baz": "123456",
            "struct": {
                "foo": "bar"
            }
        },
        "waitingFor": {
            "varName1": {
                "node": "node_uuid_1",
                "conditionData": "serialized instance of the condition using serialize()",
                "rootClass": "ezcWorkflowConditionIsEqual",
                "value": "100"
            },
            "varName2": {
                "node": "node_uuid_2",
                "conditionData": "serialized instance of the condition using serialize()",
                "rootClass": "ezcWorkflowConditionInArray",
                "value": ["foo", "bar", "baz"]
            }
        },
        "threads": [{
                "parentId": 1,
                "numSiblings": 1
            }
        ],
        "states": [{
                "nodeId": 1,
                "data": {
                    "foo": "bar"
                },
                "activatedFrom": "ezcWorkflowNodeAction",
                "threadId": 0
            }
        ]
    }

The key "value" and "values" in the "waitingFor" section of the execution can only be set for the build in conditions
and maybe through an interface for other userland conditions. Users could then implement views to automatically
resume workflows:

function(doc) {
    if (doc.type == "zeta_workflow_execution") {
        for(var wfv in doc.waitingFor) {
            var wfvar = doc.waitingFor[wfv];

            switch (wfvar.rootClass) {
                case 'ezcWorkflowConditionInArray':
                    for (var i in wfvar.values) {
                        emit([wfv, wfvar.rootClass, wfvar.values[i]], doc);
                    }
                    break;
                default:
                    emit([wfv, wfvar.rootClass, wfvar.value], doc);
                    break;
            }
        }
    }
}

In an This way you could query for "key=["var1", "ezcWorkflowConditionIsEqual", 1000]" and get all executions
that have a variable "var1" with an equal condition that is expecting 1000.


Main classes
============

-   **ezcWorkflowCouchDBWorkflow**

-   **ezcWorkflowCouchDBExecution**

-   **ezcWorkflowCouchDBQueryableCondition**

    Interface with a method "getQueryValue()" that can be used to persist view readable data of the condition.

